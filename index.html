<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Drew Shahoud</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
            font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Fira Code', monospace;
        }

        canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }

        .content {
            position: relative;
            z-index: 10;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 2rem;
            text-align: center;
        }

        .text-block {
            color: #fff;
            max-width: 600px;
        }

        .text-block p {
            font-size: clamp(1rem, 3vw, 1.4rem);
            line-height: 1.8;
            font-weight: 400;
            letter-spacing: 0.02em;
            margin-bottom: 0.5em;
        }

        .text-block p:first-child {
            font-size: clamp(1.5rem, 5vw, 2.2rem);
            font-weight: 700;
            margin-bottom: 1em;
            letter-spacing: -0.02em;
        }

        .text-block p:nth-child(4) {
            margin-top: 1.5em;
            font-weight: 600;
        }

        .text-block p:last-child {
            font-weight: 700;
            font-style: italic;
        }

        /* Glitch overlay */
        .glitch-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
            opacity: 0;
        }

        .glitch-overlay.active {
            animation: glitchFlash 200ms ease-out;
        }

        .glitch-overlay::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.15),
                rgba(0, 0, 0, 0.15) 1px,
                transparent 1px,
                transparent 2px
            );
        }

        @keyframes glitchFlash {
            0% {
                opacity: 1;
                transform: translate(0);
                filter: hue-rotate(0deg);
            }
            20% {
                transform: translate(-5px, 2px);
                filter: hue-rotate(90deg);
            }
            40% {
                transform: translate(5px, -2px);
                filter: hue-rotate(180deg);
            }
            60% {
                transform: translate(-3px, -1px);
                filter: hue-rotate(270deg);
            }
            80% {
                transform: translate(3px, 1px);
                filter: hue-rotate(360deg);
            }
            100% {
                opacity: 0;
                transform: translate(0);
            }
        }

        /* Screen shake */
        .shake {
            animation: screenShake 200ms ease-out;
        }

        @keyframes screenShake {
            0%, 100% { transform: translate(0); }
            10% { transform: translate(-8px, 4px); }
            20% { transform: translate(8px, -4px); }
            30% { transform: translate(-6px, 2px); }
            40% { transform: translate(6px, -2px); }
            50% { transform: translate(-4px, 4px); }
            60% { transform: translate(4px, -4px); }
            70% { transform: translate(-2px, 2px); }
            80% { transform: translate(2px, -2px); }
            90% { transform: translate(-1px, 1px); }
        }

        /* RGB split on content */
        .rgb-split {
            animation: rgbSplit 200ms ease-out;
        }

        @keyframes rgbSplit {
            0% {
                text-shadow: 0 0 0 #fff;
            }
            25% {
                text-shadow: -4px 0 #ff0000, 4px 0 #00ffff;
            }
            50% {
                text-shadow: 4px 0 #ff0000, -4px 0 #00ffff;
            }
            75% {
                text-shadow: -2px 0 #ff0000, 2px 0 #00ffff;
            }
            100% {
                text-shadow: 0 0 0 #fff;
            }
        }

        /* Scan lines */
        .scanlines {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 99;
            opacity: 0;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.3),
                rgba(0, 0, 0, 0.3) 1px,
                transparent 1px,
                transparent 3px
            );
        }

        .scanlines.active {
            animation: scanlineFlash 200ms ease-out;
        }

        @keyframes scanlineFlash {
            0% { opacity: 1; }
            100% { opacity: 0; }
        }

        /* Static noise */
        .static-noise {
            position: fixed;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            pointer-events: none;
            z-index: 98;
            opacity: 0;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
        }

        .static-noise.active {
            animation: staticFlash 200ms ease-out;
        }

        @keyframes staticFlash {
            0% { opacity: 0.4; transform: translate(0, 0); }
            25% { opacity: 0.3; transform: translate(-10%, 5%); }
            50% { opacity: 0.5; transform: translate(5%, -10%); }
            75% { opacity: 0.2; transform: translate(-5%, 10%); }
            100% { opacity: 0; transform: translate(0, 0); }
        }

        /* Popup modal */
        .popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #000;
            border: 2px solid #fff;
            padding: 2rem 3rem;
            z-index: 200;
            max-width: 90vw;
            text-align: center;
            display: none;
        }

        .popup.visible {
            display: block;
            animation: popupIn 150ms ease-out;
        }

        @keyframes popupIn {
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.9);
            }
            100% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }

        .popup p {
            color: #fff;
            font-size: clamp(0.9rem, 2.5vw, 1.1rem);
            line-height: 1.6;
            font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Fira Code', monospace;
        }
    </style>
</head>
<body>
    <canvas id="topo"></canvas>

    <div class="content" id="content">
        <div class="text-block" id="textBlock">
            <p>I'm Drew Shahoud.</p>
            <p>Commercial real estate investor and developer.</p>
            <p>Business consultant.</p>
            <p>Text me.</p>
            <p>Don't have my number?</p>
            <p>Find it.</p>
        </div>
    </div>

    <div class="glitch-overlay" id="glitchOverlay"></div>
    <div class="scanlines" id="scanlines"></div>
    <div class="static-noise" id="staticNoise"></div>

    <div class="popup" id="popup">
        <p>please stop trying to scroll. There is nothing more. This is literally it. Nothing to scroll to.</p>
    </div>

    <script>
        // Simplex noise implementation
        const SimplexNoise = (function() {
            const F2 = 0.5 * (Math.sqrt(3) - 1);
            const G2 = (3 - Math.sqrt(3)) / 6;
            const grad3 = [[1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],[1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],[0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]];

            function SimplexNoise(seed) {
                this.p = new Uint8Array(256);
                this.perm = new Uint8Array(512);
                this.permMod12 = new Uint8Array(512);

                const random = seed ? mulberry32(seed) : Math.random;
                for (let i = 0; i < 256; i++) this.p[i] = i;
                for (let i = 255; i > 0; i--) {
                    const j = Math.floor(random() * (i + 1));
                    [this.p[i], this.p[j]] = [this.p[j], this.p[i]];
                }
                for (let i = 0; i < 512; i++) {
                    this.perm[i] = this.p[i & 255];
                    this.permMod12[i] = this.perm[i] % 12;
                }
            }

            function mulberry32(a) {
                return function() {
                    let t = a += 0x6D2B79F5;
                    t = Math.imul(t ^ t >>> 15, t | 1);
                    t ^= t + Math.imul(t ^ t >>> 7, t | 61);
                    return ((t ^ t >>> 14) >>> 0) / 4294967296;
                };
            }

            SimplexNoise.prototype.noise2D = function(x, y) {
                const { perm, permMod12 } = this;
                let n0, n1, n2;
                const s = (x + y) * F2;
                const i = Math.floor(x + s);
                const j = Math.floor(y + s);
                const t = (i + j) * G2;
                const X0 = i - t;
                const Y0 = j - t;
                const x0 = x - X0;
                const y0 = y - Y0;
                let i1, j1;
                if (x0 > y0) { i1 = 1; j1 = 0; }
                else { i1 = 0; j1 = 1; }
                const x1 = x0 - i1 + G2;
                const y1 = y0 - j1 + G2;
                const x2 = x0 - 1 + 2 * G2;
                const y2 = y0 - 1 + 2 * G2;
                const ii = i & 255;
                const jj = j & 255;
                const gi0 = permMod12[ii + perm[jj]];
                const gi1 = permMod12[ii + i1 + perm[jj + j1]];
                const gi2 = permMod12[ii + 1 + perm[jj + 1]];
                let t0 = 0.5 - x0*x0 - y0*y0;
                if (t0 < 0) n0 = 0;
                else {
                    t0 *= t0;
                    n0 = t0 * t0 * (grad3[gi0][0]*x0 + grad3[gi0][1]*y0);
                }
                let t1 = 0.5 - x1*x1 - y1*y1;
                if (t1 < 0) n1 = 0;
                else {
                    t1 *= t1;
                    n1 = t1 * t1 * (grad3[gi1][0]*x1 + grad3[gi1][1]*y1);
                }
                let t2 = 0.5 - x2*x2 - y2*y2;
                if (t2 < 0) n2 = 0;
                else {
                    t2 *= t2;
                    n2 = t2 * t2 * (grad3[gi2][0]*x2 + grad3[gi2][1]*y2);
                }
                return 70 * (n0 + n1 + n2);
            };

            return SimplexNoise;
        })();

        // Canvas setup
        const canvas = document.getElementById('topo');
        const ctx = canvas.getContext('2d');
        const simplex = new SimplexNoise(42);

        let width, height;
        let time = 0;
        let isRed = false;
        let redTimeout = null;

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        }
        resize();
        window.addEventListener('resize', resize);

        // Topo line drawing
        function drawTopoLines() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, width, height);

            const scale = 0.003;
            const levels = 12;
            const lineWidth = 1.5;

            // Animate threshold offset
            const thresholdOffset = (Math.sin(time * 0.5) * 0.5 + 0.5) * 0.1;

            // Color based on state
            const baseColor = isRed ? [220, 60, 60] : [255, 255, 255];

            ctx.lineWidth = lineWidth;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            for (let level = 0; level < levels; level++) {
                const threshold = (level / levels) + thresholdOffset;
                const alpha = 0.15 + (Math.sin(time * 2 + level * 0.5) * 0.5 + 0.5) * 0.4;

                ctx.strokeStyle = `rgba(${baseColor[0]}, ${baseColor[1]}, ${baseColor[2]}, ${alpha})`;
                ctx.beginPath();

                // March through grid and find contour crossings
                const step = 8;
                for (let y = 0; y < height; y += step) {
                    for (let x = 0; x < width; x += step) {
                        const v00 = (simplex.noise2D(x * scale + time * 0.1, y * scale) + 1) / 2;
                        const v10 = (simplex.noise2D((x + step) * scale + time * 0.1, y * scale) + 1) / 2;
                        const v01 = (simplex.noise2D(x * scale + time * 0.1, (y + step) * scale) + 1) / 2;
                        const v11 = (simplex.noise2D((x + step) * scale + time * 0.1, (y + step) * scale) + 1) / 2;

                        // Check edges for contour crossings
                        const edges = [];

                        if ((v00 < threshold) !== (v10 < threshold)) {
                            const t = (threshold - v00) / (v10 - v00);
                            edges.push([x + t * step, y]);
                        }
                        if ((v10 < threshold) !== (v11 < threshold)) {
                            const t = (threshold - v10) / (v11 - v10);
                            edges.push([x + step, y + t * step]);
                        }
                        if ((v01 < threshold) !== (v11 < threshold)) {
                            const t = (threshold - v01) / (v11 - v01);
                            edges.push([x + t * step, y + step]);
                        }
                        if ((v00 < threshold) !== (v01 < threshold)) {
                            const t = (threshold - v00) / (v01 - v00);
                            edges.push([x, y + t * step]);
                        }

                        if (edges.length >= 2) {
                            ctx.moveTo(edges[0][0], edges[0][1]);
                            ctx.lineTo(edges[1][0], edges[1][1]);
                        }
                    }
                }
                ctx.stroke();
            }
        }

        // Animation loop
        function animate() {
            time += 0.016; // ~60fps timestep
            drawTopoLines();
            requestAnimationFrame(animate);
        }
        animate();

        // Glitch effect
        const glitchOverlay = document.getElementById('glitchOverlay');
        const scanlines = document.getElementById('scanlines');
        const staticNoise = document.getElementById('staticNoise');
        const content = document.getElementById('content');
        const textBlock = document.getElementById('textBlock');

        function triggerGlitch() {
            // Remove existing animation classes
            glitchOverlay.classList.remove('active');
            scanlines.classList.remove('active');
            staticNoise.classList.remove('active');
            content.classList.remove('shake');
            textBlock.classList.remove('rgb-split');

            // Force reflow
            void glitchOverlay.offsetWidth;

            // Add animation classes
            glitchOverlay.classList.add('active');
            scanlines.classList.add('active');
            staticNoise.classList.add('active');
            content.classList.add('shake');
            textBlock.classList.add('rgb-split');

            // Clean up after animation
            setTimeout(() => {
                glitchOverlay.classList.remove('active');
                scanlines.classList.remove('active');
                staticNoise.classList.remove('active');
                content.classList.remove('shake');
                textBlock.classList.remove('rgb-split');
            }, 250);
        }

        // Popup handling
        const popup = document.getElementById('popup');
        let popupShown = false;
        let popupAutoHideTimeout = null;

        function hidePopup() {
            if (popupShown) {
                popup.classList.remove('visible');
                popupShown = false;
                if (popupAutoHideTimeout) {
                    clearTimeout(popupAutoHideTimeout);
                    popupAutoHideTimeout = null;
                }
            }
        }

        function showPopup() {
            if (!popupShown) {
                popupShown = true;
                popup.classList.add('visible');
            }
            // Reset auto-hide timer
            if (popupAutoHideTimeout) clearTimeout(popupAutoHideTimeout);
            popupAutoHideTimeout = setTimeout(() => {
                hidePopup();
            }, 2500);
        }

        // Click handler - glitch on any click, dismiss popup
        document.addEventListener('click', (e) => {
            triggerGlitch();
            hidePopup();
        });

        // Touch handler for mobile
        document.addEventListener('touchstart', (e) => {
            triggerGlitch();
            hidePopup();
        }, { passive: true });

        // Scroll handler
        function handleScroll(e) {
            // Prevent actual scrolling
            e.preventDefault();

            // Trigger glitch
            triggerGlitch();

            // Go red
            if (!isRed) {
                isRed = true;
                if (redTimeout) clearTimeout(redTimeout);
                redTimeout = setTimeout(() => {
                    isRed = false;
                }, 3000);
            }

            // Show popup
            showPopup();
        }

        // Various scroll event listeners
        document.addEventListener('wheel', handleScroll, { passive: false });
        document.addEventListener('touchmove', handleScroll, { passive: false });
        document.addEventListener('scroll', handleScroll, { passive: false });

        // Keyboard scroll prevention
        document.addEventListener('keydown', (e) => {
            const scrollKeys = ['ArrowUp', 'ArrowDown', 'PageUp', 'PageDown', 'Home', 'End', ' '];
            if (scrollKeys.includes(e.key)) {
                e.preventDefault();
                handleScroll(e);
            }
        });
    </script>
</body>
</html>
